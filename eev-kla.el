;;; eev-kla.el -- kill link to anchor and friends.  -*- lexical-binding: nil; -*-

;; Copyright (C) 2022 Free Software Foundation, Inc.
;;
;; This file is part of GNU eev.
;;
;; GNU eev is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; GNU eev is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
;;
;; Author:     Eduardo Ochs <eduardoochs@gmail.com>
;; Maintainer: Eduardo Ochs <eduardoochs@gmail.com>
;; Version:    20221119
;; Keywords:   e-scripts
;;
;; Latest version: <http://angg.twu.net/eev-current/eev-kla.el>
;;       htmlized: <http://angg.twu.net/eev-current/eev-kla.el.html>
;;       See also: <http://angg.twu.net/eev-current/eev-beginner.el.html>
;;                 <http://angg.twu.net/eev-intros/find-eev-intro.html>
;;                                                (find-eev-intro)

;; «.tests»			(to "tests")
;; «.intro»			(to "intro")
;;  «.test»			(to "test")
;;
;; «.variables»			(to "variables")
;; «.ee-kl-expand»		(to "ee-kl-expand")
;; «.default-args»		(to "default-args")
;;
;; «.best-lrcd»			(to "best-lrcd")
;; «.ee-kl-r-c-d»		(to "ee-kl-r-c-d")
;; «.shorter-fnames»		(to "shorter-fnames")
;; «.generate-sexps»		(to "generate-sexps")
;; «.ee-kl-kill»		(to "ee-kl-kill")
;; «.kill-sexps»		(to "kill-sexps")
;; «.ee-kl-insert»		(to "ee-kl-insert")
;; «.eekla2»			(to "eekla2")
;; «.aliases»			(to "aliases")




;;; Commentary:

;; «tests»  (to ".tests")
;; Most of the docs about eev-kla.el are in this intro:
;;
;;   http://angg.twu.net/eev-intros/find-kla-intro.html
;;                                 (find-kla-intro)
;;
;; Here are some tests that need to be run from a file. Try:
;;
;;   (ee-kl-anchor)
;;   (ee-kl-c)
;;   (ee-kl-sexp-kla)
;;   (ee-kl-sexp-klf)
;;   (ee-kl-sexp-klt)
;;
;; And then:
;;
;;   M-x eekla
;;   M-x eeklf
;;   M-x eeklt


;; WARNING (2022nov15): This is being rewritten!
;; One of my presentations at the EmacsConf2022 will be about
;; eev-kla.el. Its page is:
;;
;;   http://angg.twu.net/emacsconf2022-kla.html
;;
;; Right now - 2022nov15 - I am in the middle of rewriting both and
;; the code and the docs of eev-kla.el almost completely. The docs are
;; being moved to:


;;
;;   «intro»  (to ".intro")
;; 1. Very short introduction
;; ==========================
;; This:
;;
;;   (find-eev "eev-kla.el" "intro")
;;
;; is a short hyperlink to the anchor "intro" above. The standard way
;; to create a link like that is using `find-here-links', refining,
;; and shrinking, and that way needs many keys. It is explained here:
;;
;;   (find-saving-links-intro "2.3. The base case 3")
;;
;; This file implements another way to generate links like the one
;; in the beginning of this section. Try this:
;;
;;   M-x eekla
;;
;; You will see a message like this one
;;
;;   Copied to the kill ring: (find-eev "eev-kla.el" "intro")
;;
;; in the echo area. Then go to the your notes, paste that link with
;; `C-y', and follow it - it will take you back here.
;;
;;
;;
;; 8. `eekla' and friends
;; ======================
;; At the moment this file implements these commands:
;;
;;   1) `M-x eekla', that <K>ills a <L>ink to an <A>nchor.
;;      See: (find-anchors-intro "3. The preceding tag" "M-1 M-h M-w")
;;           (find-refining-intro "5. Pointing to anchors")
;;
;;         «test»  (to ".test")
;;
;;      To test this, run `M-x eekla' here. It will highlight the
;;      anchor above ("test") for a fraction of a second and will show
;;      this message in the echo area:
;;
;;        Copied to the kill ring: (find-eev "eev-kla.el" "test")
;;
;;   2) `M-x eeklf', that <K>ills a <L>ink to a <F>ile.
;;       To test this, just run `M-x eeklf'. You will see this message
;;       in the echo area:
;;
;;         Copied to the kill ring: (find-eevfile "eev-kla.el")
;;
;;   3) `M-x eeklas': <K>ill a <L>ink to an <A>nchor and <S>tring.
;;      This is similar to `M-x eekla', but if "refines" the link
;;      generated by `M-x eekla' by adding the region between the
;;      point and the mark. For example, is the region is this "blah"
;;      then `M-x eeklas' with show this message:
;;
;;        Copied to the kill ring: (find-eev "eev-kla.el" "test" "blah")
;;
;;   4) `M-x eeklfs': <K>ill a <L>ink to a <F>ile and <S>string.
;;      If the region is this "bleh" then `M-x eeklfs' will show
;;      this message:
;;
;;        Copied to the kill ring: (find-eevfile "eev-kla.el" "bleh")
;;
;;   5) `M-x eeklt': <K>ills a <L>ink made with (<T>o ...).
;;      To test this, run `M-x eeklt' here. You will see this message
;;      in the echo area:
;;
;;         Copied to the kill ring: (to "test")
;;
;;   6) `M-x ee-kl-insert' and `M-x eekla2', that are explained in the
;;      next section.
;;
;;
;;
;; 9. Aliases
;; ==========
;; The last section of this file - i.e.:
;;
;;   (find-eev "eev-kla.el" "aliases")
;;
;; suggests some aliases - for example, `M-x kla' for `M-x eekla'.
;; From here onwards I will suppose that these aliases are active.
;;
;;
;;
;; 10. Bidirectional links
;; =======================
;; This page
;;
;;    http://angg.twu.net/emacsconf2022-kla.html
;;
;; has one of my submissions to the EmacsConf2022; its title is
;; "Bidirectional links with eev", and that title refers to something
;; that I will show in the last part - probably the last minute - of
;; my video. The idea is that sometimes we have two windows displaying
;; different files, like this:
;;
;;    _____________________
;;   |          |          |
;;   | ;; «a»   | # «b»    |
;;   | _        | _        |
;;   |          |          |
;;   |__________|__________|
;;   |__foo.el__|__bar.py__|
;;
;; In the drawing above the first window is visiting a file called
;; "foo.el" (in Elisp) and the second one is visiting a file called
;; "bar.py" (in Python). In the first one the point is just after an
;; anchor whose tag is "a", and in the second one the point is after
;; an anchor whose tag is "b".
;;
;; We want to create a link from the "a" to the "b", and a link from
;; the "b" to the "a", with few keystrokes. Or, more precisely...
;;
;; An `M-x kla' in the first window generates a link like this,
;;
;;   (find-foo "foo.el" "a")
;;
;; and an `M-x kla' in the second window generates one like this:
;;
;;   (find-bar "bar.py" "b")
;;
;; We want a VERY VERY FAST WAY to put the first link on the second
;; window, and the second link in the first window, to get something
;; like this:
;;    ____________________________________________________________
;;   |                              |                             |
;;   | ;; «a»                       | # «b»                       |
;;   | ;; (find-bar "bar.py" "b")   | # (find-foo "foo.el" "a")   |
;;   | _                            | _                           |
;;   |                              |                             |
;;   |______________________________|_____________________________|
;;   |__foo.el______________________|__bar.py_____________________|
;;
;; we also want these links to be inserted in comments. In Elisp
;; comments start with ";;", and in Python they start with "#".
;;
;; In pseudocode, what we want is roughly this:
;;
;;   1. start at the first window
;;   2. generate a link to the "a" with `M-x kla'
;;   3. switch to the next window
;;   4. insert that link with a comment prefix and a newline
;;   5. generate a link to the "b" with `M-x kla'
;;   6. switch back to the first window
;;   7. insert that link with a comment prefix and a newline
;;
;; The command `M-x kla2' (or `M-x eekla2') does that.
;;
;; 11. Overridable functions
;; =========================
;; On my machine I have some "living fossils" - the ones mentioned
;; in `find-angg-es-links',
;;
;;   (find-angg-es-links)
;;   (find-angg-es-links 2 "living fossil")
;;   (find-eev "eev-tlinks.el" "find-angg-es-links")
;;   (find-eev "eev-tlinks.el" "find-angg-es-links" "living fossil")
;;
;; ...and a few other ones. My trick for making `kla' and `klas'
;; support them is to override `ee-kl-shorterfname', and redefine it
;; in my ~/.emacs by a function that deletes the suffixes.
;;
;; Also, a friend of mine uses Doom Emacs, that uses straight.el, and
;; he told me that in Doom Emacs this
;;
;;   (find-eev "eev-code.el" "code-c-d-s")
;;   (find-eev "eev-code.el" "code-c-d-s" "ee-eev-source-directory")
;;
;; points to a directory that only has .el files, and all these ".el"s
;; are symlinks. This breaks `ee-kl-shortfname', and I'm experimenting
;; with variants of `ee-kl-shortfname' - that are hacks, and that have
;; to be put in his ~/.emacs to override the original function - that
;; contain code to handle these symlinks correctly.
;;
;;
;; 12. Please test!
;; ================
;; ..and get in touch, either through the mailing list,
;;
;;   https://lists.gnu.org/archive/html/eev/
;;   https://lists.nongnu.org/mailman/listinfo/eev
;;
;; or by one of the ways listed here:
;;
;;   http://angg.twu.net/contact.html
;;
;; Thanks! =)




;; «variables»  (to ".variables")

(defvar ee-kl-transforms nil
  "Set this if you need to support symlinks in eev-kla.el.
The value of this variable should be list of (regexp replacement) pairs.")





;;;                  _    _                                       _ 
;;;   ___  ___      | | _| |       _____  ___ __   __ _ _ __   __| |
;;;  / _ \/ _ \_____| |/ / |_____ / _ \ \/ / '_ \ / _` | '_ \ / _` |
;;; |  __/  __/_____|   <| |_____|  __/>  <| |_) | (_| | | | | (_| |
;;;  \___|\___|     |_|\_\_|      \___/_/\_\ .__/ \__,_|_| |_|\__,_|
;;;                                        |_|                      
;; «ee-kl-expand»  (to ".ee-kl-expand")
;; See: (find-kla-intro "9. Symlinks")
;;
(defun ee-kl-expand (fname)
  "Expand FNAME using `ee-expand'. Use other hacks if needed."
  (ee-kl-transform (ee-expand fname)))

(defun ee-kl-transform (fname)
  "Transform FNAME into a canonical form.
This is a hack to support symlinks in eev-kla.el. See the source."
  (cl-loop for (regexp repl) in ee-kl-transforms
           do (setq fname (replace-regexp-in-string regexp repl fname)))
  fname)


;;;  ____        __             _ _                         
;;; |  _ \  ___ / _| __ _ _   _| | |_    __ _ _ __ __ _ ___ 
;;; | | | |/ _ \ |_ / _` | | | | | __|  / _` | '__/ _` / __|
;;; | |_| |  __/  _| (_| | |_| | | |_  | (_| | | | (_| \__ \
;;; |____/ \___|_|  \__,_|\__,_|_|\__|  \__,_|_|  \__, |___/
;;;                                               |___/     
;; «default-args»  (to ".default-args")
;; See: (find-kla-intro "6. `cl-defun'")
;;      (find-kla-intro "7. The default `c', `d', and `r'")

(defun ee-kl-fname ()
  (or (buffer-file-name) default-directory))

(defun ee-kl-anchor ()
  (ee-preceding-tag-flash))

(defun ee-kl-region ()
  (buffer-substring-no-properties (point) (mark)))


;;;  ____            _     _                               _ 
;;; | __ )  ___  ___| |_  | |      _ __       ___       __| |
;;; |  _ \ / _ \/ __| __| | |_____| '__|____ / __|____ / _` |
;;; | |_) |  __/\__ \ |_  | |_____| | |_____| (_|_____| (_| |
;;; |____/ \___||___/\__| |_|     |_|        \___|     \__,_|
;;;                                                          
;; «best-lrcd»  (to ".best-lrcd")
;; These functions try to choose the "best" `c-d' for a filename. They
;; filter `ee-code-c-d-pairs' to find all the `c-d's that "match" that
;; filename, then they choose the best one, and they return it
;; converted to an `l-r-c-d'. The ideas and the terminology are
;; explained here:
;;   (find-kla-intro "4. The best `l-r-c-d'")
;;
;; Tests: (find-eppp (ee-kl-cds))
;;        (find-eppp (ee-kl-lrcds))
;;                   (ee-kl-lrcd)

(defun ee-kl-prefixp (prefix str)
  "If STR starts with PREFIX then return STR minus that prefix.
When STR doesn't start with PREFIX, return nil."
  (and (<= (length prefix) (length str))
       (equal prefix (substring str 0 (length prefix)))
       (substring str (length prefix))))

(defun ee-kl-cds ()
  "Return a copy of `ee-code-c-d-pairs' with all `d's ee-kl-expanded."
  (cl-loop for (c d) in ee-code-c-d-pairs
	   collect (list c (ee-kl-expand d))))

(cl-defun ee-kl-lrcds (&key fname)
  "Return all the `c-d's in (ee-kl-cds) that match FNAME.
Each matching `c-d' is converted to an `l-r-c-d'."
  (setq fname (or fname (ee-kl-fname)))
  (cl-loop for (c d) in (ee-kl-cds)
	   if (ee-kl-prefixp d fname)
	   collect (let* ((r (ee-kl-prefixp d fname))
			  (l (length r)))
		     (list l r c d))))

(cl-defun ee-kl-lrcd (&key fname)
  "Return the best lrcd in (ee-kl-lrcds FNAME).
If (ee-kl-lrcds FNAME) doesn't return any matching `lrcd's, return nil."
  (setq fname (or fname (ee-kl-fname)))
  (let* ((lrcds (ee-kl-lrcds :fname fname))
	 (l< (lambda (lrcd1 lrcd2) (< (car lrcd1) (car lrcd2))))
	 (lrcds-sorted (sort lrcds l<)))
    (car lrcds-sorted)))


;;;  ____        __             _ _                         _ 
;;; |  _ \  ___ / _| __ _ _   _| | |_   _ __    ___      __| |
;;; | | | |/ _ \ |_ / _` | | | | | __| | '__|  / __|    / _` |
;;; | |_| |  __/  _| (_| | |_| | | |_  | | _  | (__ _  | (_| |
;;; |____/ \___|_|  \__,_|\__,_|_|\__| |_|( )  \___( )  \__,_|
;;;                                       |/       |/         
;; «ee-kl-r-c-d»  (to ".ee-kl-r-c-d")
;; See: (find-kla-intro "7. The default `c', `d', and `r'")
;; Tests: (ee-kl-r)
;;        (ee-kl-c)
;;        (ee-kl-d)

(cl-defun ee-kl-r (&key fname)
  (setq fname (or fname (ee-kl-fname)))
  (nth 1 (ee-kl-lrcd :fname fname)))

(cl-defun ee-kl-c (&key fname)
  (setq fname (or fname (ee-kl-fname)))
  (nth 2 (ee-kl-lrcd :fname fname)))

(cl-defun ee-kl-d (&key fname)
  (setq fname (or fname (ee-kl-fname)))
  (nth 3 (ee-kl-lrcd :fname fname)))


;; «shorter-fnames»  (to ".shorter-fnames")
;;
(cl-defun ee-kl-shortfname (&key fname c r)
  (setq fname (or fname (ee-kl-fname))
	r     (or r     (ee-kl-r :fname fname)))
  r)

(cl-defun ee-kl-shorterfname (&key fname c r)
  (setq fname (or fname (ee-kl-fname))
	r     (or r     (ee-kl-r :fname fname)))
  r)



;;;  ____                      
;;; / ___|  _____  ___ __  ___ 
;;; \___ \ / _ \ \/ / '_ \/ __|
;;;  ___) |  __/>  <| |_) \__ \
;;; |____/ \___/_/\_\ .__/|___/
;;;                 |_|        
;;
;; «generate-sexps»  (to ".generate-sexps")
;; Functions that generate sexps. Tests:
;;   (ee-kl-sexp-kla)
;;   (ee-kl-sexp-klas :region "foo")
;;   (ee-kl-sexp-klf)
;;   (ee-kl-sexp-klfs :region "foo")
;;   (ee-kl-find-c)
;;   (ee-kl-c)
;;
(cl-defun ee-kl-find-c (&key fname c)
  "Generate a symbol of the form find-{c}."
  (setq fname  (or fname  (ee-kl-fname))
	c      (or c      (ee-kl-c :fname fname)))
  (intern (format "find-%s" c)))

(cl-defun ee-kl-find-cfile (&key fname c)
  "Generate a symbol of the form find-{c}file."
  (setq fname  (or fname  (ee-kl-fname))
	c      (or c      (ee-kl-c)))
  (intern (format "find-%sfile" c)))

(cl-defun ee-kl-sexp-kla (&key fname c r anchor)
  "<K>ill <l>ink to <a>nchor - make sexp."
  (setq fname  (or fname  (ee-kl-fname))
	c      (or c      (ee-kl-c :fname fname))
	r      (or r      (ee-kl-r :fname fname))
	anchor (or anchor (ee-kl-anchor)))
  (list (ee-kl-find-c       :fname fname :c c)
	(ee-kl-shorterfname :fname fname :c c :r r)
	anchor))

(cl-defun ee-kl-sexp-klas (&key fname c r anchor region)
  "<K>ill <l>ink to <a>nchor and <s>tring - make sexp."
  (setq fname  (or fname  (ee-kl-fname))
	c      (or c      (ee-kl-c :fname fname))
	r      (or r      (ee-kl-r :fname fname))
	anchor (or anchor (ee-kl-anchor))
	region (or region (ee-kl-region)))
  (list (ee-kl-find-c       :fname fname :c c)
	(ee-kl-shorterfname :fname fname :c c :r r)
	anchor
	region))

(cl-defun ee-kl-sexp-klf (&key fname c r)
  "<K>ill <l>ink to <f>ile - make sexp."
  (setq fname (or fname (ee-kl-fname))
	c     (or c     (ee-kl-c :fname fname))
	r     (or r     (ee-kl-r :fname fname)))
  (list (ee-kl-find-cfile :fname fname :c c)
	(ee-kl-shortfname :fname fname :c c :r r)))

(cl-defun ee-kl-sexp-klfs (&key fname c r region)
  "<K>ill <l>ink to <f>ile and <s>tring - make sexp."
  (setq fname  (or fname (ee-kl-fname))
	c      (or c     (ee-kl-c :fname fname))
	r      (or r     (ee-kl-r :fname fname))
	region (or r     (ee-kl-region)))
  (list (ee-kl-find-cfile :fname fname :c c)
	(ee-kl-shortfname :fname fname :c c :r r)
	region))

(cl-defun ee-kl-sexp-klt (&key anchor)
  "<K>ill <l>ink to a (<t>o ...) - make sexp."
  (setq anchor (or anchor (ee-kl-anchor)))
  (list 'to anchor))



;;;                  _    _       _    _ _ _ 
;;;   ___  ___      | | _| |     | | _(_) | |
;;;  / _ \/ _ \_____| |/ / |_____| |/ / | | |
;;; |  __/  __/_____|   <| |_____|   <| | | |
;;;  \___|\___|     |_|\_\_|     |_|\_\_|_|_|
;;;                                          
;; «ee-kl-kill»  (to ".ee-kl-kill")
;; Tests: (ee-kl-link-to-string "(foo)\n")
;;        (ee-kl-link-to-string '(foo))

(defun ee-kl-kill (link)
  "Kill LINK and show a message.
Here \"kill\" means \"put it in the kill ring.\""
  (setq link (ee-kl-link-to-string link))
  (let ((link0 (replace-regexp-in-string "\n$" "" link)))
    (kill-new link)
    (message "Copied to the kill ring: %s" link0)))

(defun ee-kl-link-to-string (link)
  "Convert LINK to a string using `ee-S'.
If LINK is already a string, return it unchanged.
If LINK is a sexp, convert it to a string with `ee-S' and append
a newline to it."
  (if (stringp link)
      link
    (concat (ee-S link) "\n")))



;;;  _  ___ _ _     
;;; | |/ (_) | |___ 
;;; | ' /| | | / __|
;;; | . \| | | \__ \
;;; |_|\_\_|_|_|___/
;;;                 
;; «kill-sexps»  (to ".kill-sexps")
;; Commands that push sexps into the kill ring.
;;
(defun eekla ()
  "<K>ill <L>ink to <A>nchor.
Put in the kill ring a link to the preceding anchor."
  (interactive)
  (ee-kl-kill (ee-kl-sexp-kla)))

(defun eeklas ()
  "<K>ill <L>ink to <A>nchor and <S>tring.
Put in the kill ring a link to the preceding anchor."
  (interactive)
  (ee-kl-kill (ee-kl-sexp-klas)))

(defun eeklf ()
  "<K>ill <L>ink to <F>ile."
  (interactive)
  (ee-kl-kill (ee-kl-sexp-klf)))

(defun eeklfs ()
  "<K>ill <L>ink to <F>ile and <S>tring."
  (interactive)
  (ee-kl-kill (ee-kl-sexp-klfs)))

(defun eeklt ()
  "<K>ill <L>ink to a (<T>o ...)."
  (interactive)
  (ee-kl-kill (ee-kl-sexp-klt)))



;;;                  _    _       _                     _   
;;;   ___  ___      | | _| |     (_)_ __  ___  ___ _ __| |_ 
;;;  / _ \/ _ \_____| |/ / |_____| | '_ \/ __|/ _ \ '__| __|
;;; |  __/  __/_____|   <| |_____| | | | \__ \  __/ |  | |_ 
;;;  \___|\___|     |_|\_\_|     |_|_| |_|___/\___|_|   \__|
;;;                                                         
;; «ee-kl-insert»  (to ".ee-kl-insert")
;; Tests: (ee-kl-comment-prefix)
;;        (ee-kl-insert "(foo)\n")
;;
(defun ee-kl-comment-prefix (&optional mode)
  "This a quick hack. Override it to add support for more languages."
  (let ((plist '(emacs-lisp-mode ";; "
		 haskell-mode    "-- "
		 lua-mode        "-- "
		 python-mode     "# "
		 agda2-mode      "-- "
		 latex-mode      "%% ")))
    (plist-get plist (or mode major-mode))))

(defun ee-kl-link-to-string-with-comment (link)
  (concat (or (ee-kl-comment-prefix) "# ")
	  (ee-kl-link-to-string link)))

(defun ee-kl-insert (&optional link)
  "Insert (ee-kl-comment-prefix) and then LINK."
  (interactive)
  (insert (ee-kl-link-to-string-with-comment (car kill-ring))))




;;;            _    _       ____  
;;;   ___  ___| | _| | __ _|___ \ 
;;;  / _ \/ _ \ |/ / |/ _` | __) |
;;; |  __/  __/   <| | (_| |/ __/ 
;;;  \___|\___|_|\_\_|\__,_|_____|
;;;                               
;; «eekla2»  (to ".eekla2")
;; See: (find-eev "eev-kla.el" "intro" "10. Bidirectional links")

;; Based on:
;;   (find-eev "eev-flash.el" "specs")
;;   (find-eev "eev-tlinks.el" "ee-copy-rest" "eeflash-copy")
;; but lasts longer.
;;
(defvar ee-kla2-flash-spec '(highlight 2.0))

(defun ee-kla2-flash (pos1 pos2)
  "Highlight the region between POS1 and POS2 using `ee-kla2-flash-spec'."
  (eeflash pos1 (point) ee-kla2-flash-spec))

(defun ee-kla2-goto-bol ()
  "Move to the beginning of the line.
When not at BOL, move to the beginning of the next line."
  (when (not (= (ee-bol) (point)))	; when not at bol
    (move-beginning-of-line 2))		; do <down> C-a
  (point))

(defun ee-kla2-insert (link)
  "Move to the beginning of the line, insert LINK, and highlight it."
  (let* ((line (ee-kl-link-to-string-with-comment link))
	 (pos-before-line (ee-kla2-goto-bol)))
    (insert line)
    (ee-kla2-flash pos-before-line (point))))

(defun eekla2 ()
  "Insert a link \"to here\" \"there\" and a link \"to there\" \"here\"."
  (interactive)
  (let* ((link1 (ee-kl-sexp-kla))
	 (link2 (prog2 (other-window 1)
		    (ee-kl-sexp-kla)
		  (other-window -1))))
    (ee-kla2-insert link2)
    (other-window 1)
    (ee-kla2-insert link1)
    (other-window -1)))



;;;     _    _ _                     
;;;    / \  | (_) __ _ ___  ___  ___ 
;;;   / _ \ | | |/ _` / __|/ _ \/ __|
;;;  / ___ \| | | (_| \__ \  __/\__ \
;;; /_/   \_\_|_|\__,_|___/\___||___/
;;;                                  
;; «aliases»  (to ".aliases")
;; See: (find-kla-intro "10. Aliases")
;; I use these aliases:
;; (defalias 'kla  'eekla)
;; (defalias 'klas 'eeklas)
;; (defalias 'klf  'eeklf)
;; (defalias 'klfs 'eeklfs)
;; (defalias 'klt  'eeklt)
;; (defalias 'kli  'ee-kl-insert)
;; (defalias 'kla2 'eekla2)

(provide 'eev-kla)


;; Local Variables:
;; coding:            utf-8-unix
;; no-byte-compile:   t
;; End:
